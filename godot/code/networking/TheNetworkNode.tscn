[gd_scene load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

var unique_persistant_ids = 0
var Server = null
var Client
var validate_ipv4 = RegEx.new()

var upnp = null
var pp_udp = null
var search_udp_broadcast = false
var host_udp_broadcast = false
var message_loops = []
    
func invert_peers(peers_data):
    if get_tree().get_network_peer() == null:
        var peers_inverted = {}
        for key in peers_data:
            peers_inverted[peers_data[key]] = key
        # NOTE: For JSON Objects must have keys that are strings not Integers.
        # Invert players and do not store in JSON.
        Settings.Network.set_data(\"peers_inverted\", peers_inverted)
    elif get_tree().is_network_server():
        var peers_inverted = {}
        for key in peers_data:
            peers_inverted[peers_data[key]] = key
        # NOTE: For JSON Objects must have keys that are strings not Integers.
        # Invert players and do not store in JSON.
        Settings.Network.set_data(\"peers_inverted\", peers_inverted)

# Called when the node enters the scene tree for the first time.
func _ready():
    # warning-ignore:return_value_discarded
    get_tree().connect(\"network_peer_connected\", self, \"_client_connected\")
    # warning-ignore:return_value_discarded
    get_tree().connect(\"network_peer_disconnected\", self, \"_client_disconnected\")
    # warning-ignore:return_value_discarded
    get_tree().connect(\"connected_to_server\", self, \"_connected_ok\")
    # warning-ignore:return_value_discarded
    get_tree().connect(\"connection_failed\", self, \"_connection_failed\")
    # warning-ignore:return_value_discarded
    get_tree().connect(\"server_disconnected\", self, \"_server_disconnected\")
    validate_ipv4.compile(\"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\")
    Settings.Session.register_data(\"server_ip\", \"\")
    Settings.Session.register_data(\"server_ignore_list\", [])
    Settings.Session.register_data(\"mup_id\", null)  # mup_id = my_unique_persistant_id
    Settings.Network.register_data(\"peers\", {\"0\": 1})
    invert_peers(Settings.Network.get_data(\"peers\"))
    Settings.Network.register_data(\"peers_ready\", {})
    Settings.Network.register_data(\"peers_minimum\", Settings.MIN_PLAYERS)
    # peer_status can be one of [\"connected\", \"disconnected\", \"connecting\", \"reconnecting\", \"reconnected\", \"identifying\"]
    Settings.Network.register_data(\"peers_status\", {\"0\": \"connected\"})
    Settings.Session.connect(Settings.Session.monitor_data(\"server_possible_ips\"), self, \"setup_server_part2\")
    Settings.Network.connect(Settings.Network.monitor_data(\"peers\"), self, \"invert_peers\")
    Settings.Network.connect(Settings.Network.monitor_data(\"peers_ready\"), self, \"check_if_all_peers_ready\")
    set_process(false)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(__):
    for msg_loop in message_loops:
        call_deferred(msg_loop)

remote func sync_var(classname, var_name, var_val=null):   # class_name is a reserved word in GDScript
    Settings.Log(\"RPC: 'sync_var' sender_id = \" + str(Settings.get_tree().get_rpc_sender_id()) +
                \" classname=\" + str(classname) + \" var_name=\" + str(var_name) + \"  var_val=\" + str(var_val), \"info\")
    match classname:
        \"Network\":
            Settings.Network.set_data(var_name, var_val, true)
        \"InGame\":
            Settings.InGame.set_data(var_name, var_val, true)

func reset_networking():
    get_tree().set_network_peer(null)
    if Server == null:
        if Client != null:
            Client.queue_free()
    else:
        Server.queue_free()

#### SCENETREE SERVER NETWORKING FUNCTIONS
func _client_connected(godot_peer_id):  # Client Equals Another Player
    Settings.Log(\"Peer Connected with peer id: \" + str(godot_peer_id))
    if get_tree().is_network_server():
        if godot_peer_id in Settings.Network.get_data(\"peers\").values():
            var peers_inverted = Settings.Network.get_data(\"peers_inverted\")
            var peers_status = Settings.Network.get_data(\"peers_status\")
            peers_status[peers_inverted[godot_peer_id]] = \"identifying\"
            Settings.Network.set_data(\"peers_status\", peers_status)
    
func _client_disconnected(godot_peer_id):  # Client Equals Another Player
    Settings.Log(\"Peer Disconnected with peer id: \" + str(godot_peer_id))
    if get_tree().is_network_server():
        if godot_peer_id in Settings.Network.get_data(\"peers\").values():
            var peers_inverted = Settings.Network.get_data(\"peers_inverted\")
            var peers_status = Settings.Network.get_data(\"peers_status\")
            peers_status[peers_inverted[godot_peer_id]] = \"disconnected\"
            Settings.Network.set_data(\"peers_status\", peers_status)

func assign_unique_id():
    # Rationale: Although Godot does something like this, it misses our use case.
    # If a player disconnects and then reconnects thier peer_id will be new each time.
    # We want players to be able to drop out. But if they comeback to us with the
    # same unique_persistant_ids, then they are the same player.
    unique_persistant_ids += 1
    return str(unique_persistant_ids)
    
remote func identify(pup_id, godot_peer_id):
    var real_rpc_id = get_tree().get_rpc_sender_id()
    if real_rpc_id != godot_peer_id:
        # Spoofing or Bad Client
        Settings.Log(\"Bad Remote Client is Spoofing. Real rpc_id: \" + str(real_rpc_id) + \" Spoofed rpc_id: \" + str(godot_peer_id))
        Server.disconnect_peer(real_rpc_id, true)
        return
    else:
        if get_tree().is_network_server():
            var peers_status = Settings.Network.get_data(\"peers_status\")
            var peers_inverted = Settings.Network.get_data(\"peers_inverted\")
            var peers = Settings.Network.get_data(\"peers\")
            if pup_id == null:
                var new_up_id = assign_unique_id()
                peers[new_up_id] = godot_peer_id
                Settings.Network.set_data(\"peers\", peers)
                rpc_id(godot_peer_id, \"set_mup_id\", new_up_id)
                peers_status[new_up_id] = \"connected\"
            else:
                if Settings.Network.get_data(\"peers\").has(pup_id):
                    if Settings.Network.get_data(\"peers\")[pup_id] == godot_peer_id:
                        Settings.Log(\"Player already identified with the same rpc_id.\")
                        peers_status[peers_inverted[godot_peer_id]] = \"reconnected\"
                    else:
                        peers[pup_id] = godot_peer_id
                        Settings.Network.set_data(\"peers\", peers)
                        peers_status[peers_inverted[godot_peer_id]] = \"reconnected\"
                else:
                    Settings.Log(\"Error: player_unique_persistant_id, does not exist yet in peers dict. Bad Client?\")
                    Server.disconnect_peer(real_rpc_id, true)
                    return
            Settings.Network.sync_peer(godot_peer_id)
            Settings.InGame.sync_peer(godot_peer_id)
            Settings.Network.set_data(\"peers_status\", peers_status)

func setup_server_part1():
    message_loops.append(\"_hosting_so_toss_udp_broadcast\")
    reset_networking()
    Settings.Session.set_data(\"mup_id\", \"0\")
    if Settings.Session.get_data(\"server_ip\") == \"\":
        var local_ips = IP.get_local_addresses()
        var valid_ipv4_matches = []
        for ip in local_ips:
            var a_match = validate_ipv4.search(ip)
            if a_match != null:
                valid_ipv4_matches.append(a_match.get_strings()[0])
        valid_ipv4_matches.erase(\"127.0.0.1\")
        Settings.Session.set_data(\"server_possible_ips\", valid_ipv4_matches)
        if valid_ipv4_matches.size() == 0:
            Settings.Log(\"Error: Not Implemented Yet!\", \"error\")
            Settings.Log(\"    No valid IPv4 addresses.\", \"error\")
        elif valid_ipv4_matches.size() == 1:
            Settings.Session.set_data(\"server_ip\", valid_ipv4_matches[0])
            call_deferred(\"setup_server_part2\")
        else:  # > 1
            get_tree().call_group(\"Camera\", \"pan_camera\", 4, -1)
            
    else:
        Settings.Session.set_data(\"server_ip\", Settings.Session.get_data(\"server_ip\"))
        call_deferred(\"setup_server_part2\")
        
func setup_server_part2(possible_ips=null):
    if possible_ips != null:
        if Settings.Session.get_data(\"server_possible_ips\").size() == 1:
            Settings.Session.set_data(\"server_ip\", Settings.Session.get_data(\"server_possible_ips\")[0])
        else:
            return
        Settings.Session.set_data(\"server_port\", Settings.NETWORK_LAN_PORT)
        Server = NetworkedMultiplayerENet.new()
        Server.set_bind_ip(Settings.Session.get_data(\"server_ip\"))
        Server.create_server(Settings.Session.get_data(\"server_port\"), Settings.MAX_PLAYERS + Settings.MAX_OBSERVERS)
        get_tree().set_network_peer(Server)
        Settings.Session.set_data(\"connection_status\", \"connected\")
        host_udp_broadcast = true
        call_deferred(\"_hosting_send_udp_broadcast\")
        get_tree().call_group(\"Camera\", \"pan_camera\", 4, 0)

func check_if_all_peers_ready(peers_ready):
    if get_tree().is_network_server():
        var all_ready = true
        if peers_ready.size() == Settings.Network.get_data(\"peers\").size() and peers_ready.size() >= Settings.MIN_PLAYERS:
            for peer in peers_ready:
                if peers_ready[peer] == false:
                    all_ready = false
        else:
            all_ready = false
        if all_ready:
            Settings.Session.set_data(\"all_ready\", true)
            call_deferred(\"synchronize_start_game_data\")
     
func synchronize_start_game_data():
    if get_tree().is_network_server():
        var peers_ready = Settings.Network.get_data(\"peers_ready\")  # Reuse
        for peer in peers_ready:
            peers_ready[peer] = false
        Settings.Network.set_data(\"peers_ready\", peers_ready)
        Settings.InGame.set_data(\"player_type_by_player_id\", {\"0\":\"network\", \"1\":\"network\"})
        Settings.InGame.set_data(\"color_by_player_id\", {\"0\":\"253a9a\", \"1\":\"960e0e\"})
        Settings.InGame.set_data(\"tile_type_by_player_id\", {\"0\":3, \"1\":2})
        Settings.InGame.set_data(\"names_by_player_id\", {\"0\":\"Blue\", \"1\":\"Red\"})
        Settings.InGame.set_data(\"scores_by_player_id\", {\"0\":2, \"1\":2})
        Settings.InGame.set_data(\"current_players_turn\", \"1\")
        get_tree().call_group(\"Container\", \"do_remote_goto_scene\", \"res://scenes/BattleScenes/GridMultiPlayer.tscn\")

#### SCENETREE CLIENT NETWORKING FUNCTIONS
func _connected_ok():
    Settings.Log(\"Connection Established, my peer id is: \" + str(get_tree().get_network_unique_id()))
    get_tree().call_group(\"Camera\", \"pan_camera\", 4, 0)
    rpc_id(1, \"identify\", Settings.Session.get_data(\"mup_id\"), get_tree().get_network_unique_id())
    
func _connection_failed():
    Settings.Log(\"Connection failed.\")
    get_tree().set_network_peer(null)
    
func _server_disconnected():
    Settings.Log(\"Connection terminated by the server.\")
    get_tree().set_network_peer(null)
    
func setup_as_client():
    Settings.Session.set_data(\"connection_status\", \"connecting\")
    Settings.Log(Settings.Session.get_data(\"server_ip\") + \" \" + str(Settings.Session.get_data(\"server_port\")))
    Client = NetworkedMultiplayerENet.new()
    Client.create_client(Settings.Session.get_data(\"server_ip\"), Settings.Session.get_data(\"server_port\"))
    get_tree().set_network_peer(Client)
    
remote func set_mup_id(new_id):
    if not get_tree().is_network_server():
        Settings.Log(\"RPC: 'set_my_unique_persistant_id' sender_id = \" + str(get_tree().get_rpc_sender_id()), \"info\")
        if get_tree().get_rpc_sender_id() == 1:
            Settings.Session.set_data(\"mup_id\", new_id)

#### UDP BroadCast For LAN
func _search_for_peers():
    pp_udp = PacketPeerUDP.new()
    pp_udp.set_dest_address(\"255.255.255.255\", Settings.NETWORK_BROADCAST_LAN_PORT)
    pp_udp.listen(Settings.NETWORK_BROADCAST_LAN_PORT)
    Settings.Session.register_data(\"udp_peer_dict\", {})
    search_udp_broadcast = true
    message_loops.append(\"_udp_broadcast_rxd\")
    set_process(true)
    call_deferred(\"_udp_broadcast_tx\")
    
func _udp_broadcast_tx():
    while search_udp_broadcast:
        pp_udp.put_var([Settings.UDP_BROADCAST_GREETING, Settings.Session.get_data(\"server_ip\"), Settings.Session.get_data(\"server_port\")])
        # Remove peers that have not broadcast lately. > 3 seconds.
        var udp_peer_dict = Settings.Session.get_data(\"udp_peer_dict\")
        for udp_peer in udp_peer_dict:
            if OS.get_system_time_secs() - udp_peer_dict[udp_peer] > 3:
                udp_peer_dict.erase(udp_peer)
        Settings.Session.set_data(\"udp_peer_dict\", udp_peer_dict)
        yield(get_tree().create_timer(0.3), \"timeout\")
    
func _udp_broadcast_rxd():
    while pp_udp.get_available_packet_count() > 0:
        var udp_var = pp_udp.get_var()
        var udp_peer_ip = pp_udp.get_packet_ip()
        if udp_peer_ip in IP.get_local_addresses():
            pass  # Throw it away.
        else:
            Settings.Log(\"Got UDP broadcast from: \" + udp_peer_ip +  \" of \" + str(udp_var))
            if typeof(udp_var) == TYPE_ARRAY:
                if udp_var[0] == Settings.UDP_BROADCAST_GREETING:
                    var udp_peer_dict = Settings.Session.get_data(\"udp_peer_dict\")
                    udp_peer_dict[udp_peer_ip] = OS.get_system_time_secs()
                    Settings.Session.set_data(\"udp_peer_dict\", udp_peer_dict)
                elif udp_var[0] == Settings.UDP_BROADCAST_HOST:
                    if not Settings.Session.get_data(\"server_invite\"):
                        if udp_var[1] in Settings.Session.get_data(\"server_ignore_list\"):
                            pass
                        else:
                            Settings.Session.set_data(\"server_invite\", true)
                            get_tree().call_group(\"Camera\", \"pan_camera\", 3, 0)
                            Settings.Log(\"Server IP = \" + udp_var[1] + \":\" + str(udp_var[2]))
                            Settings.Session.set_data(\"server_ip\", udp_var[1])
                            Settings.Session.set_data(\"server_port\", udp_var[2])
            
func _hosting_so_toss_udp_broadcast():
    while pp_udp.get_available_packet_count() > 0:
        var udp_var = pp_udp.get_var()
        var udp_peer_ip = pp_udp.get_packet_ip()
        if udp_peer_ip in IP.get_local_addresses():
            pass  # Throw it away.
        else:
            if typeof(udp_var) == TYPE_ARRAY:
                if udp_var[0] == Settings.UDP_BROADCAST_HOST:
                    Settings.Log(\"Warning: Another server is hosting at \" + udp_var[1] + \":\" + str(udp_var[2]))
                    Settings.Log(\"    Verified IP Address is: \" + udp_peer_ip)

func _hosting_send_udp_broadcast():
    while host_udp_broadcast:
        pp_udp.put_var([Settings.UDP_BROADCAST_HOST, Settings.Session.get_data(\"server_ip\"), Settings.Session.get_data(\"server_port\")])
        yield(get_tree().create_timer(0.3), \"timeout\")
 
func udp_peer_selected(peer_ip):
    Settings.Log(\"UDP Peer Selected: \" + str(peer_ip))
    stop_udp_peer_search()   
    Settings.Session.set_data(\"players_ip\", peer_ip)
    setup_server_part1()  
    
func stop_udp_peer_search():
    Settings.Log(\"Stopping UPD Peer Search.\")
    search_udp_broadcast = false
    message_loops.remove(\"_udp_broadcast_rxd\")

#### UPNP
func _init_upnp():
    upnp = UPNP.new()
    upnp.discover(2000, 2, \"InternetGatewayDevice\")
    upnp.add_port_mapping(Settings.NETWORK_LAN_PORT)
    upnp.delete_port_mapping(Settings.NETWORK_LAN_PORT)
"

[node name="TheNetworkNode" type="Node"]
script = SubResource( 1 )
